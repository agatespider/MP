# 객체를 바르게 만들기

* 개요
* 원시형
* 객체리터널
* 모듈패턴
* 정리

## 개요

## 원시형과 원시형객체
Javascript의 원시형은 String, Number, Boolean, null, undefined 총 5가지 종류가 있습니다. 그리고 최근에 ECMAScript6에서 새로운 Symbol이 추가가 되었습니다.

원시형 변수는 값은 있고 프로퍼티가 없습니다. 그래서 아래와 같은 코드는 에러가 날 것 같지만 이상하게도 문제없이 실행이 됩니다.

    var str = "testStr";
    console.log(str.length);    //결과: 7 
    // str은 원시형 문자형 데이터 변수인데? 왜 length프로퍼티를 가질수 있는거지?
    
실제로 원시형 데이터에는 프로퍼티를 추가할 수가 없습니다. 하지만 재미있게도 Javascript는 암묵적으로 원시형 데이터를 원시형 데이터에 어울리는 wrapper객체로 감싸서 해석을 합니다.    
    
위 코드를 예로 들면 Javascript엔진은 str.length 코드를 해석할때 객체로 먼가 하려나 보다 하고 예상을 합니다. 그리고 str로 String 객체를 생성하고 실제 이 객체의 length 프로퍼티를 참조하게 되는 것입니다.

물론 이렇게 만들어진 String객체는 곧바로 가비지 컬렉션 대상이 되어서 사라지게 됩니다.
    
여태까지 원시형 데이터에 대해 간단히 설명했습니다.

실제로 원시형 데이터는 상수 변수에 담아놓고 그 변수를 사용하는 형태로 많이 사용을 합니다. 원시형 데이터는 객체가 아니므로 프로퍼티를 심을 수가 없습니다.

만약에 프로퍼티를 담고 싶다면 원시형이 아닌 객체를 만들어서 사용을 해야합니다.

## 객체리터널

아래 코드처럼 선언한 객체를 객체리터널(object literal)이라고 말합니다.
    
    { name: 'Love', genus: 'Do you feel', genius: Do you need' }
        
객체리터널 생성 방법은 단순객체리터널(bare object liternal)과 함수반환값을 통한 생성 방법 이렇게 2가지 방법이 존재합니다.
        
    // 단순객체리터널
    var love = { name: 'Love', genus: 'Do you feel', genius: Do you need' }
    
    // 함수반환값을 통한 객체리터널             
    var mav = function() {
        ...생략
        return { name: 'mav', genus: 'picture', genius: 'type' }
    }
    
둘중 하나가 다른 하나보다 더 DRY합니다. 예를 들면 같은 프로퍼티를 가진 객체리터널을 단순객체리터널방식으로 여러개 생성할때 실수를 할 수 있습니다. 프로퍼티를 빼먹거나 오타도 칠 수 있겠죠.

이런 실수를 방지하고자 함수에서 객체리터널을 반환한다는 가정하에서 TDD방식으로 함수가 원하는 프로퍼티를 지닌 객체를 반환하는지 확인을 할 수 있습니다.

안탑갑지만 단순객체리터널은 전혀 테스트를 할 수 없습니다.

또한 함수를 사용할 경우 의존성주입을 사용해서 원하는 객체리터널을 생성하거나 반환할 수 있습니다. 단순객체리터널은 불가능합니다.

이런 단점들이 있기 때문에 단순객체리터널은 확실히 테스트를 마친 코드에서 생성된게 아니라면 중요한 어플리케이션에선 권장하지 않습니다.

이러한 객체리터널은 데이터를 뭉치로 사용할때 쓰기 편합니다. 예를 들면 함수의 파라메터가 워낙 많을 경우 객체리터널을 사용할 수 있습니다. 만약 객체리터널을 인자로 받는 함수에서 인자로 받은 객체리터널에 프로퍼티가 하나도 없으면 기본값을 사용하라는 신호로 받아 들일 수도 있습니다.

이런 객체리터널을 받는 함수는 어떤 프로퍼티 조합도 대비할 수 있도록 테스트가 많이 필요합니다. 예를 들면 isValid 같은 메서드로 검증 가능한 객체를 사용하는 방안을 고민을 해야합니다.

## 모듈패턴
모듈 패턴은 Javascript에서 가장 많이 쓰이는 패턴중 하나입니다. 모듈 패턴은 데이터 숨김이 목적인 함수가 이런 데이터를 접근하고 제어할 수 있는 API를 제공하는 객체를 반환하는 패턴입니다.

이 패턴은 두가지 유형이 있는데 하나는 임의로 함수를 호출하여 생성하는 모듈 또 하나는 선언과 동시에 실행하는 함수에 기반을 둔 모듈입니다.

즉시모듈생성

    // 해당 어플리케이션에서만 사용할 수 있는 모든 객체(모듈)을 담아 놓은 전역 객체를 선언하여 namespace처럼 활용합니다.
    var FishApp = FishApp || {};
    
    // FishApp namespace에 속한 모듈
    // 이 함수는 FishMaker라는 다른 함수에 의존하며 fishMaker는 주입이 가능합니다.
    FishApp.wildFishSimulator = function(fishMaker) {
        // private 변수
        var fishes = [];
    
        // api를 반환
        return {
            addFish: function(name, species) {
                fishes.push(fishMaker.make(name, species));
            },
            getFishesCount: function() {
                return fishes.length;
            }
        };
    };
    
    // 모듈을 아래처럼 사용을 할 수 있습니다.
    var preserve = FishApp.wildFishSimulator(realFishMaker);
    preserve.addFish('붕어', '붕어계');

이 모듈은 객체리터널을 반환하나 fishMaker같은 의존성을 외부함수에 주입해서 리터널에서 참조하게 만들 수도 있습니다.

다른 모듈에도 이 모듈을 주입을 할 수 있어서 확장성에도 유리합니다.



