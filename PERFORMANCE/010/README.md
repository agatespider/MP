# 소스코드 최적화

## 1. 중점 파악 요소

### 1.1 불필요한 작업 제거
    
    단순 정보성 로깅 부분이 존재하는가?
    로깅을 하지 않는데 로깅을 위한 문자열 혹은 데이터를 만들고 있는가?
    파싱이나 환경설정 로딩과 같은 작업이 반복 수행되는가?
    
### 1.2 로직 최적화
    
    lock 범위를 최소화 하거나 lock을 회피 가능한다?
    집합 데이터에 대한 검색 방식은 적절한가?
    문자열 처리에 오버해드가 존재하는가?
    반복 처리 로직이 존재하는가?
    기능이 단순하지만 호출 회수가 많아서 성능에 영향을 끼치는가?
    
### 1.3 적극적인 캐시 사용
    
    영업일, 계정과목, 공통코드 같은 소량 테이블에 빈번한 조회가 발생하는가?
    배치 같은 경우 결과가 한정적인 데이터에 대한 반복조회가 많이 있는가?
    포털 화면에 보여지는 게시물 목록 같은 것을 캐시 할 수 있는가?
    
### 1.4 효율적인 아키택쳐 구성
    
    프로그램 흐름상에서 병목이 존재하는가?
    대량건 조회는 가능한가?
    송수신 전문 포맷과 크기는 시스템 특성과 네트워크 환경에 적합한가?
    한 서비스 내에서 내,외부 연계 시스템과 빈번하게 통신하는가?
    
### 1.5 최적화 우선순위
    
    1. 기반환경: GC시간이 50%넘는 시간이라면 GC개선작업부터 해야한다.
    2. 프레임워크: 요청/응답 전문처리, 트랜잭션 관리, SQL수행, 로깅, 작업 선/후 처리, 분산, 대외 인터페이스등 거의 프레임워크가 담당한다.
                  즉 전체 응답 시간에서 DB처리 시간을 제외하고 거의 프레임워크 수행시간이나 마찬가지니 중요하다.
    3. 공통모듈: 공통코드 조회 같은 공통으로 사용하기 위한 모듈이며 최적화 우선순위가 높다.
                여기서 성능에 문제가 생기면 이걸 사용하는 모든것이 문제가 발생한다.
    4. 업무모듈: 도메인 업무이며 많이 쓰는 업무 모듈일수록 빨리 분석해서 처리 한다.
    
## 2. 불필요한 작업 제거
로그는 사용자에게 프로그램에 대한 추가 정보를 제공하기 위해 있는 것이지 로그가 있느냐 없느냐가 중요한게 아니다.
     
어플리케이션이 복잡해짐에 따라 디버깅을 위해 복잡하면 복잡할 수록 많은 로깅이 쌓이게 된다. 하지만 운영시점에 로그를 정리하지 않으면 과다하고 잘못된 로그로 인해서 성능에 영향을 끼치게 된다.

### 2.1 로깅 수준
     
    1. 운영시에는 경고, 에러 수준으로 로깅을 설정한다.
    2. 추적이나 디버그, 정보성격의 로그를 에러나 심각으로 남기지 않는다.
    
#### 2.1.2 로깅을 위한 불필요한 메세지 생성
운영 시점에 로그의 수준을 Error로 잡아도 로깅 메세지를 만드는 과정이 생겨서 성능에 문제가 생긴다. 예를 들면 다음과 같다.
     
     log.debug('요청받은 데이터: " + data);    // String + Object
      
     // 아래처럼 로깅 상태를 통해서 로직자체를 호출 못하도록 설정한다.
     if(log.debug.isEnabled()) {
        log.debug('요청받은 데이터: " + data);
     }
     
String + Object같은 형태는 debug가 호출되기 전에 String과 Object가 하나의 문자열로 만드는 연산을 하기 때문에 왠만하면 위처럼 처리 해줘야 한다.
      
#### 2.1.3 트랜잭션 저널 로그
로그기반 통계를 내는 시스템에서는 서비스 요청과 응답에 대한 로그를 남기는 서비스가 핵심기능은 아니지만 중요하다. TPS가 낮으면 DB에 로그를 넣어도 되는데 만약 TPS가 높으면 DB에 로그를 쌓을 경우 병목현상으로 성능 저하가 발생하기도 한다.
      
이에 따른 개선 방안은 아래와 같다.
      
    1. 해시파티션: DB테이블을 해시 파티션으로 구성해 집중되는 입력 부하를 여러 파티션에 균등 분할 해서 입력한다.(해시 파티션이 지원안되면 범위 파티션으로 해시효과를 낼수 있다.)
    2. 비동기처리: 통계용 로그는 바로 사용하지 않으므로 Queue나 File에 저장했다가 차후 별도의 스레드나 프로세스로 대량으로 DB에 저장한다.
    3. 비핵심업무제외: 핵심 업무만 로그를 수집한다.
    4. 저장데이터최소화: 요청,응답에대한 모든 정보를 저장 할 수도 있지만 오직 필요한 데이터만 저장한다.
    5. 내부연계제외: 외부 인터페이스만 로깅하고 내부 시스템간의 연계는 제외한다.
     
### 2.2 불필요한 로직
보통 공통 모듈을 사용할때 불필요한 로직이 들어가는데, 예를 들면 사용자의 ID, 이름만 알면되는데 공통모듈을 통해서 사용자 정보를 가져올때 사용자의 모든정보를 불필요하게 전달하는 것을 예로 들수 있다.
    
주민등록번호나, 패스워드는 암호화되서 저장되기 때문에 이것을 복호화 하거나 하는 과정도 성능에 영향을 미친다. 가능하다면 업무의 서비스 패턴을 고려해서 세분화된 정보를 제공하는 함수들도 다양히 제공해야 한다.
    
### 2.3 반복 로직   
업무를 위해서 꼭 필요한 로직이지만 반복적으로 수행함으로써 성능을 저하시키는 경우를 말하는데 한번만 수행하고 값을 캐싱했다가 재활용하도록 로직을 구성하는 것이 바람직하다.


## 3. 로직 최적화

### 3.1 Lock
Java에서 제공하는 클래스 중에선 어떤 클래스를 사용하느냐에 따라서 내부에 Lock이 있기도 하고 없기도 하다.

예를 들어 문자열을 생성하는 StringBuffer같은 경우 여러 스레드가 동시에 데이터를 수정하는 경우가 아니면 StringBuilder로 바꾸는게 성능상 좋다.
 
StringBuffer는 여러스레드에서 동시 수정이 가능하도록 Thread-safe하게 synchronized로 lock처리를 하고 StringBuilder는 lock처리가 없다. 당연히 한 쓰레드에서 동작한다면 StringBuilder를 사용하는게 lock을 열고 닫을 필요없어서 CPU 클럭을 조금이나마 덜 사용한다.
 
    자바의 동기화 여부 목록
    String(동기): StringBuffer
    String(비동기): StringBuilder
    List(동기): Vector, Stack, Collections.synchronizedList()
    List(비동기): ArrayList, LinkedList
    Set(동기): Collections.syncchronizedSet()
    Set(비동기): HashSet, TreeSet
    Map(동기): Hashtable, ConcurrentHashMap, Collections.synchronizedMap()
    Map(비동기): HashMap, WeekHashMap, TreeMap
    Queue(동기): ConcurrentLinkedQueue
    Queue(비동기): LinkedList
    
### 3.2 문자열 처리 개선
Java의 String객체에서 제공하는 format이나 replaceAll같은 메서드가 같편해서 자주 사용하는데 해당 메서드를 사용하지 않고 동일한 기능을 구현하는 것이 성능상에 용이하다.

#### 3.2.1 String.format
String.format은 내부적으로 많은 복잡한 로직을 거친다. stack을 보면 알수 있다. 그래서 동일한 기능을 동작시키더라도 StringBuiler와 거의 10배 차이가 난다.

    String.format("%s is %d years old, er, young","AI",45); // 549ms
    new StringBuilder(50).append("AI").append("is").append(45).append(" years old, er, young);  // 50ms
    
#### 3.2.2 String.replaceAll
replaceAll내부는 정규표현식을 사용하는 형태로 구현이 되어있다. 그래서 간단한 형태의 문자열인경우 직접 개발하는 편이 더 빠르다.

source/ReplaceAllTest.java를 실행해보면 replaceAll은 364962 nano초가 걸렷고 이미로 만든 replaceAllCustom은 29583nano초가 걸렷다. 거의 10배 이상의 시간이 발생했다.

#### 3.2.3 reflection 제거
reflection은 프로그램에 유연성과 확장성을 제공하지만 이를 구현하기 위해 객체를 생성하고 메서드를 호출하기 위한 준비 하나하나가 직접 메서드를 호출하는 것 만큼 든다.

Spring의 AOP를 이용해서 공통 메서드를 수만번 호출하는데 총 응답시간에 10%이상이 리플랙션 처리에 소요되는 경우도 있었다. 직접 호출이 가능하다면 reflection을 통해 호출하지 말도록 하자.

#### 3.2.4 아이디 채번
DB에서 ID를 저장할때 primary key를 구성하기 위해 채번을 한다. application안에서 채번이 이루어질 경우 괜챃은데 DB내에서 채번이 발생하는 경우 성능 저하의 원인 되기도 한다.

DB는 보통 아래와 같이 세가지 방식으로 채번이 이루어진다.

    1. SELECT MAX+1 FROM 저장테이블 : 쓰지말자
    2. SELECT NUM+1 FROM 체번테이블 WHERE = 유형 FOR UPDATE ... : 쓰지말자
    3. SEQUENCE 사용 : 그나마 가장 성능이 우수하다. 보통 시퀀스는 번호를 설정하는 만큼 캐싱해 뒀다가 사용하는 옵션이 있다.
    
가장 성능을 좋게 하려면 DB에서 채번을 하지 않는 것이다. 단순히 숫자가 필요하다면 WAS의 인스턴스나 서버의 고유번호, 시스템시간, 순차번호등을 조합해 GID를 생성하듯이 만들어 사용하는게 좋다.
    
DB시퀀스에서 캐쉬하는 기능이 있듯이 어플리케이션에서 채번할 키를 캐시를 해서 사용 할 수도 있다.
     
#### 3.2.5 날짜계산
현재 날짜를 구하거나 날짜를 더하거나 할때 java8이전에는 java.util.Calendar클래스를 이용해 계산한다. 보통 몇십번 호출시에는 크게 성능저하는 보이지 않지만 보험 해약환급금 예시표같이 한 서비스 호출에 날짜 관련메서드를 수십만 번까지 사용하는경우는 문제가 된다.
      
Calandar보다 좀더 빠른 모듈이나 아니면 직접 구현해서 사용하는것이 좋다.
      
#### 3.2.6 시간 문자열 처리
로깅을 찍을때 시간 문자열 생성은 빈번하게 사용한다. Java에선 java.text.SimpleDateFormat을 이용하는데 어떻게 코딩하느냐에 따라 성능차이가 많이난다.
      
매번 SimpleDateFormat을 생성하면서 수행하는것보다 한번 SimpleDateFormat을 생성하고 공유해서 사용하는것이 3배정도 빠르다. (DateTextTest.java 참고)

SimpleDateFormat을 싱글턴 구조를 만들어서 사용할수있는데 SimpleDateFormat은 thread-safe하지 않다, 만약 Thread-safe하게 쓰려면 ThreadLocal을 통해 사용 할수 있다.

아니면 직접 SimpleDateFormat을 제작해서 사용하는 경우 더빠른 성능을 낼 수도 있다.

#### 3.2.7 순차 검색 제거
순차 검색이란 List를 반복하면서 처음부터 끝까지 검색하는 것을 의미한다. 여러 가지 방식들이 있겟지만 ArrayList, HashSet, 문자열배열에서 binarySearch이 3가지를 예를 들면 다음과 같은 결과가 나온다.
      
    가장빠름: HashSet의 HashSet.contains()로 검색
    보통: String[]의 binarySearch()로 검색
    느림: ArrayList에서 if에서 equals로 검색
    
#### 3.2.8 파일 입출력 단위    
파일 입출력은 Disk에 물리적인 접근이 발생해 성능 저하를 일으키는 대표적인 부분중 하나이다. 그래서 파일을 읽고 쓰는 작업이 많은 프로세스인 경우에는 세심한 주의가 필요하다. 파일 처리는 입출력단위가 큰것이 성능에 유리하다.    

OutputStream과 BufferedOutputStream을 예로 들수 있다. 우선 OutputStream에서 write할 데이터의 크기가 크면 클수록 동일 용량을 write할때보다 빠르며 Buffered는 기본 버퍼 크기가 8,192로 이 크기로 데이터를 묶어서 쌓기 때문에 그냥 OutputStreamd을 쓰는것 보다 매우 빠르다.

당연히 InputStream과 BufferedInputStream을 비교하면 BufferedInputStream이 월등히 빠르다.

그리고 각각의 write나 read시의 인자 데이터를 최대로 키우는 것이 성능상에 유리하다.

#### 3.2.9 SQL
    
    1. 바인드 변수를 사용해야 한다. SQL내에 직접 값을 설정해서 수행하면 DB가 Query를 재사용안하고 하드파싱 빈도가 증가하게 된다. 그래서 오라클인 경우 SQL실행계획과 메타정보가 있는 Shared Pool에 경합이 발생함으로 성능 저하가 발생한다.
    2. 자원은 close로 꼭 닫아준다.
    3. DB Connection은 Connection Pool을 사용해서 제어한다.
    
#### 3.2.10 BigDecimal    
float나 double 숫자 타입은 정확성이 아닌 성능위주로 설계된 부동 소수 형식을 사용하기에 일부 값이 정확하지 않고 근사값으로 표현된다.
     
그래서 실제 돈과 관련된 업무이며 소수점이 포함된 이율을 계산할때 BigDecimal이 느리지만 어쩔수 없이 쓰곤 한다.
     
어쩔수 없어서 BigDecimal을 쓰는경우 최대한 성능을 위해 아래와 같은 행동을 해야한다.

    1. Oracle JVM인 경우 1.6.0_25부터 제공되는 --XX:+AggressiveOpt옵션을 사용하면 BigDecimal연산에 대해 15%정도 성능 효과를 볼수 있다.
    2. BigDecimal을 생성시 new BigDecima(double)보다 new BigDecimal(String) 형태로 사용하길 바란다. 거의 200배 정도 차이가 난다.
    
#### 3.2.11 기타 성능 개선
    
1. 로깅을 남길때 스택 기반으로 정보를 기록할 경우 성능이 저하된다. Log4J에서 클래스명과 줄번호를 남길때 스레드 스택 기반으로 해당 정보를 획득한다.
2. Was에서 수정된 어플리케이션이 실시간으로 반영되도록 설정되면 성능이 저하된다. 당연하게도 변경된 파일이 있는지 체크하기 때문에 그렇다. 운영시점에는 서버를 재기동 해야 반영되도록 설정해야한다. 그러나 화면이 너무 자주 바뀐다면 실시간 반영 모드를 사용하기도 한다.
3. indexOf도 잘생각하고 쓰자, 문자열 탐색시 indexOf를 자주쓴느데 실제 if문으로 탐색하는거에 비해서 거의 5배 정도 느릴때도 있다.


## 4. 캐시 사용
실시간으로 보여야 하는 것들은 어쩔수 없지만 그러지 않는 것들이나 변하지 않고 공통적으로 사용하는 것들은 최대한 캐시를 하자.

### 4.1 브라우저
도메인명에 대한 주소를 캐시, 컨텐츠를 캐시
    
### 4.2 웹서버
환경설정 캐시, 콘텐츠 캐시
    
### 4.3 WAS
환경설정 캐시, 프로그램 모듈 캐시
    
### 4.4 어플리케이션
적극적으로 사용되는 부분
    
### 4.5 프레임워크
환경설정, 서비스와 프로그램 구성, 송수진 전문구조, SQL, 어플리케이션을 위한 캐시 제공
    
### 4.6 DBMS
환경설정, 테이블, 인덱스, 권한 등 DB구성정보 캐시, SQL 실행계획, 데이터


## 5. 효율적인 아키텍처 구성

### 5.1 병렬처리
### 5.2 통신전문
요청,응답의 전문은 아래와 같이 성능 차이가 존재한다. 그러니 매우 많이 데이터를 조회해 전문을 날린다면 바이너리 형태로 넘기는게 가장 성능상에 유리하며 XML이 가장 느리다.
 
    XML(느림) > JSON > 텍스트기반구분자 > 바이너리(가장빠름)

### 5.3 고객정보 조회 이력 로깅과 마스킹
예를 들면 고객정보의 이력로깅과 마스킹을 할때 클라이언트에 사용자 정보를 보낼때 로깅하는 것이 빠를지 아니면 고객정보를 조회하는 공통 모듈을 호출할때 로깅을 남길지에 관한건데 당연히 공통모듈에서 유저정보를 조회하는것은 클라이언트에서 전문을 날릴 상황이 아니여도 호출되니 클라이언트에서 전문을 생성시 로깅을 남기거나 마스킹하는게 성능상에 유리하다.

### 5.4 대량 조회 프레임워크 구성
### 5.5 내부연계시스템
ESB(Enterprise Service Bus)와 EAI(Enterprise Application Integration)또는 직접 타시스템과의 연계를 하는 경우 주의깊게 봐야하는 것은 연계 횟수다.

홈페이지는 사용자 정보, 가입 정보등등을 위해서 기간계 시스템과 연계가 이루어지는데 연계된 단위가 개별정보로 세세하게 나눠져 있어서 한서비스를 처리할때마다 연계서버를 들락날락 거리는 경우가 흔하다.

이럴경우 turn수가 증가함으로써 성능저하가 발생한다. 만약 타시스템이 성능저하로 서비스에 큐잉이 발생하면 멈춰버리는것처럼 보이는 상태가 발생한다.

연계 서비스 호출 감소 방안으로 아래와 같은 방법들이 있다.

    1. 로컬캐시사용 : 반복해서 연계호출 할 경우에 결과를 로컬 캐시에 저장해두고 사용한다.
    2. 서비스호출통합 : 타시트템에서 여러번 호출하는 경우를 찾아서 한번에 호출하도록 통합한다.
    3. 복수서비스호출 아키텍쳐 수립 : 2단계는 양쪽다 수정해야하는 케이스라 상당한 시간이 걸릴 수 있다. 그래서 기능을 구현하기전에 설계시점에서 파악하고 고려해서 여러번 호출하는 경우가 없게 설계/구현 한다.
    
### 5.6 수직/수평확장
    
    
    


    

    

     

    