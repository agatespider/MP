# SQL 기본 지식

## 1. 기본 방향
Application에서 대부분의 시간을 차지하는게 SQL처리시간이다. 그러므로 SQL처리시간을 단축하는 것이 핵심 성능 개선이 된다.

### 1.1 주요 점검 사항
Oracle기준으로 주요하게 점검해야 할 사항을 나열했다. 아래 사항을 중점으로 살펴봐야한다.

#### 1.1.1 통계

    최적 실행계획이 수립되도록 테이블 통계 정보가 존재하고 주기적으로 갱신하는가?

#### 1.1.2 인덱스
    
    적절한 인덱스를 사용하는가? 혹시 Full scan하고 있는 테이블이 있는가?
    인덱스가 있는데 사용하지 못하고 있는가?
    인덱스 수가 많아서 INSERT시에 처리시간이 오래 걸리는가?
    
#### 1.1.3 조인
    
    처리하는 데이터의 양과 연결 관계에 맞는 조인 방식이 선정되었는가?
    조인 관계에서 선행 테이블은 적합한가?
    
#### 1.1.4 테이블
    
    데이터 수정과 삭제로 테이블 조각화가 발생해 재구성 해야할 필요가 있는가?
    파티션으로 INSERT부하를 분산해 성능 개선이 가능한가?
    
## 2. SQL튜닝을 위한 기본 지식
데이터베이스는 크게 클라이언트, 엔진, 파일시스템으로 구성이된다.
    
### 2.1 클라이언트
클라이언트는 JDBC나 OCI등과 같이 DB에서 제공하는 클라이언트 모듈을 통해 데이터베이스에 조회하거나 수정할 수 있는 기능을 제공한다. 클라이언트의 개선사항은 아래와 같다.
    
    1. 복수건의 레코드를 한번의 호출로 집합 처리하거나 두개 이상의 쿼리를 한개의 쿼리로 통합 처리 하도록한다.
    2. 클라이언트에서 JDBC Statement를 캐시하거나 SQL cursor를 오픈한 상태로 유지해서 소프트 파싱을 회피해 성능을 개선한다.
    3. Fetch크기를 증가시켜 데이터베이스에서 클라이언트로 조회된 데이터를 전송 할 때 한번에 많은 데이터를 전송해서 성능을 개선할 수 있다.
    
### 2.3 데이터베이스 엔진    
엔진은 클라이언트 요청으로 파일시스템에 저장된 데이터를 조회 하거나 수정하는 기능을 담당한다. 요청 처리시 데이터 무결성을 위해서 엔진 내부에는 lock관리와 트랜잭션 관리가 이루어진다.
    
또한 장애나 비정상적인 프로세스 종료에 대비한 백업과 복구, 권한 관리등의 기능이 엔진 수준에서 제공된다.

데이터베이스 엔진은 처리 성능 개선을 위해서 동작에 필요한 기초 정보와 파일시스템에 저장된 데이터중 일부를 메모리에 캐시하고 있어서 큰 메모리를 필요로 한다. 메모리에 저장되는 주요 데이터 유형은 아래와 같다.
 
#### 2.3.1 데이터 캐시(Data Buffer)
파일시스템에 저장된 데이터가 조회되면 해당데이터를 메모리 데이터 캐시에 저장해 이후 동일 데이터 조회시 물리적인 I/O를 발생시키지 않도록 한다.

데이터 캐시는 크기가 제한적이라 새로운 데이터를 넣을때 부족하면 LRU(Least Recently Used)알고리즘에 따라 오랫동안 사용하지 않은 데이터 블럭부터 제거한다.
    
#### 2.3.2 실행계획(Shared Pool의 Library cache)
SQL이 처음 호출되면 대상 데이터를 찾는 방법이 기술돼어있는 실행계획을 만들고 이후에 동일한 SQL이 수행되면 기존에 만들어진 실행계획은 재사용한다. 

각 SQL은 실행계획을 한 개만 가지고 있어 입력되는 바인드 변수 값에 상관없이 데이터 탐색 방식은 동일하다. 바인드 변수를 안쓰고 하드코딩한다면? 그때마다 실행계획이 생길껏이다. 의미가 없어진다.

#### 2.3.3 DB정보(Shared Pool의 Dictonary 정보)
테이블 구성정보(메타정보)와 통계를 저장하고 있으면서 SQL을 검증하고 실행계획을 수립할 때 참조 한다. 사용자권한, View도 이곳에 저장된다.    
    
#### 2.3.4 복구로그(Redo log buffer)
데이터 변경 전후 내역을 저장했다가 장애가 발생시 데이터를 복구하는 용도로 사용한다. 복구 로그도 제한된 공간이기 때문에 크기가 모자를수 있으니 복구로그파일로 기존 정보를 옮긴다.

기본적으로 여러개의 파일이 순환구조를 띄고 있으며 로그 스위치가 완료된 복구 로그 파일은 아카이브 공간에 복사되어 장애시 복구로그에 없는 데이터 변경사항을 복구할때 사용된다.

#### 2.3.5 유의사항

1. 데이터 캐시는 클수록 좋지만 개선 효과가 메모리 증가에 비례해서 증가하지 않는다. 어느 수준부터는 개선효과가 감소하는 커브 곡선을 그리므로 적당한 크기를 찾아야 한다.

2. 바인드 변수를 사용하지 않으면 엔진은 서로다른 SQL로 인식한다. 당연히 실행계획은 계속 만들어지게 되고 메모리 부족으로 경합이 발생한다. 그러니 바인드 변수를 써야한다.

3. 테이블과 인덱스의 전체 블록갯수, 데이터건수, 항목별 선택도 인덱스 현황등 통계 정보를 기반으로 실행계획을 수립하는데 통계 정보가 없거나 오래되서 잘못된 실행계획이 수립되어 급격한 성능 저하를 발생시킬 수 있다.
주기적으로 테이블 통계를 갱신해서 엔진이 테이블 상태 변화에 따라 실행계획을 올바르게 변경할 수 있게 해야한다.

### 2.4 파일시스템
파일 시스템은 데이터가 영구적으로 저장되는 곳이다. 데이터를 조회, 수정시 물리적인 I/O가 발생하므로 가장 느린부분이기도 하다. 그래서 성능좋은 HDD나 disk stripe, ssd 메모리기반 스토리지를 사용하며 데이터베이스 서버와 스토리지간 채널 증설등 인프라 측면에서 갖가지 노력을 해야한다.

이보다 중요한 것은 SQL이 최적의 상태로 수행이 되어 필요이상으로 많은 데이터 블록을 파일 시스템에서 읽지 않도록 하는 것이다.

사용자와 시스템 데이터 영역중 롤백 세그먼트라는게 있는데 이것은 트랜잭션에서 롤백시 데이터를 복구하거나 사용자 프로세스의 비정상 종료시 커밋되지 않는 수정 데이터를 복구하기 위해서 변경 전 이미지를 저장하는 영역이다.

또한 데이터에 대한 읽기 일관성을 제공하기 위한 용도로 사용되는데 오라클 같은 경우 읽기 일관성의 기준이 SELECT시작 시점인데, SELECT를 시작하고 이후 실제 블록을 읽고 잇는 시점에서 블록의 데이터가 변경되었을 경우 롤백 세그먼트를 가지고 읽기 시작한 시점의 데이터로 되돌려서 보여준다.

이때 롤백 세그먼트 크기가 작을 경우 기존 데이터가 사라져 버리는데 이러면 이전 시점으로 되돌릴수 없고 Old Snapshot에러가 발생한다.
 
## 3. 블록 단위 처리 
데이터베이스의 저장구조는 데이터베이스 < 테이블 스페이스 < 세그먼트 < 익스텐트 < 블록 순으로 계층 관계를 이루고 있다.

테이블스페이스는 테이블과 인덱스를 갖는 논리 저장 단위이고, 세그먼트는 테이블과 인덱스가 포함된다. 익스텐트는 연속된 블럭의 집합으로 공간 할당의 논리적 단위이다. 따라서 테이블의 공간이 추가로 필요한 경우 새로운 익스텐트가 할당된다.

블록은 I/O의 가장 작은 단위며 할당 할수 있는 최소 단위이기도 하다. 블록은 한개 이상의 연속된 OS블록으로 구성되어 있다. 블록은 엔진이 파일시스템이나 데이터를 찾을 때 탐색하는 단위이기도 하다. 크기는 8KB, 16KB, 32KB, 64KB등 다양하게 지정할 수 있으며 블록 내에는 여러건의 레코드가 존재한다.

만약 SELECT를 호출햇는데 읽은 블록이 많다는 것은 레코드를 찾는 과장이 불합리하다는 것을 의미한다. 우리가 말하는 SQL튜닝은 이 불합리한 과정을 바로잡아 최소한의 블록을 읽고 원하는 레코드를 찾을 수 있게 하는 것이다.

예를 들어 1건의 레코드를 조회하는데 10,000블록을 읽은 쿼리와 5블록을 읽은 쿼리가 있다면 당연히 5블록을 읽은 쿼리가 성능이 훨신 우수할 것이다.

즉 튜닝이란? 읽는 블록 수를 줄여주는 것이다.

MariaDb기준에 튜닝 방안에 관해서 자료를 찾아서 차후 다시 재정리 하도록 하겠음.



