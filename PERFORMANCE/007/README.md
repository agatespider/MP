# 웹 기산 시스템 성능 개선


# 1. 화면 컨텐츠 구성 체크
서버의 응답시간이 느린경우도 많지만 리소스(이미지, 자바스크립트, 스타일시트)들이 무분별하게 많거나 커서 느린 경우도 있다.

이럴 경우는 화면을 간결하게 구성하거나 컨텐츠를 통합하거나 아니면 컨텐츠 용량을 줄이거나 압축을 해야한다.

## 1.1 컨텐츠 수 축소
예전에 비해 브라우저들이 웹서버와 동시 연결해서 다운로드 하는 연결 수가 늘긴 했지만 무수히 많은 컨텐츠 수는 느린응답시간을 제공해주게 된다.

브라우저별 최대 연결수는 [여기](http://www.browserscope.org/)에서 확인 하면 된다.

### 1.1.1 이미지
첫번째 방법은 개별 이미지를 사용해서 각각 화면을 표시하지말고 가능하다면 이미지를 1개의 이미지로 통합해서 구성하면 서버 요청수가 1번만 호출되니 성능개선에 도움이 된다.
또한 이미지 스프라이트를 사용해서 통합된 이미지파일의 여러 이미지를 개별이미지처럼 사용할 수 있다.

두번째는 화면에서 사용하는 이미지파일의 크기를 확정하는 것인데, 1000 X 1000이미지를 100 X 100으로 표현해주면 비효율적이다. 그리고 1000X1000보다 100X100이 용량이 적을 것은 당연하다.

### 1.1.2 자바스크립트
이미지와 마찬가지로 자바스크립트도 여러 js파일로 따로 빼지말고 통합화 한다.

### 1.1.3 사용하지 않는 컨텐츠 제거
당연하게도 사용하지 않은 컨텐츠는 모두 제거한다. 그래야만 서버 요청이 줄어들기 때문이다.

### 1.1.4 CDN사용
CDN은 웹서비스 제공자가 웹 서버에 있는 정적 컨텐츠를 인터넷 서비스 제공자 측에 설치된 CDN서버에 미리 저장해두고 클라이언트가 사용시 최적 경로로 컨텐츠를 제공해주는 기술이다.

### 1.1.5 텍스트 컨텐츠 축소
자바스크립트나 CSS같은 TEXT컨텐츠는 YUI Compressor나 JSMin, HTMLCompressor들을 사용해 들여쓰기, 주석, 공백들을 제거해 용량을 줄일 수 있다.
 
### 1.1.6 압축 
네트워크 환경이 열악한 경우 컨텐츠의 크기가 응답시간에 매우 큰 영향을 끼친다. 이럴땐 속도를 위해 압축을 해야한다.

CSS나 자바스크립트 같은 Text컨텐츠는 웹서버에서 제공하는 압축기능을 이용하면 1/10이하로 크기를 줄일 수 있다, 하지만 압축은 서버의 CPU를 사용하기 때문에 웹서버에 자원이 여유가 있고 전체 응답시간에 네트워크가 차지하는 비중이 클때만 사용해야 한다.

참고로 압축되어있는 컨텐츠를 또 압축해도 큰 차이는 별로 없다.

압축의 동작은 브라우저가 처리할 수 있는 압축 방식을 요청 헤더에 Accept-Encoding: gzip, deflate와 같이 담아서 요청한다.

그러면 서버는 설정된 압축 방식과 브라우저가 처리 가능한 압축방식을 검토해 가능하면 압축해서 보내고 응답해더에 Content-Encoding: deflate와 같이 사용한 압축 방식을 브라우저에 전달한다.

#### 1.1.6.1 nginx 압축 설정

    gzip  on;
    # 파일을 압축하기 위한 최소 파일 크기
    gzip_min_length 1100;
    # gzip 버퍼 크기, 4 32k 면 대부분 상황에서 적당한 크기 입니다.
    gzip_buffers 4 32k;
     # 압축을 적용할 파일타입. 파일타입은 MIME 타입을 말함.
    gzip_types text/plain application/x-javascript text/xml text/css;
    # 압축률 지정. 1 ~ 9 사이이며 9가 최고등급의 압축.
    gzip_comp_level 1;

### 1.1.7 웹가속기 사용
웹서버 앞에서 브라우저와의 통신을 최적화 해주는 역할을 한다. 보통 웹 가속기는 컨텐츠압축, 컨텐츠 캐시, 네트워크 연결 관리, SSL가속등의 역할을 한다.


## 1.2 캐시

### 1.2.1 브라우저 캐시
자동으로 브라우저에서 동작하는 캐시이다. 대국민이나 포털과 같이 사용자가 많은 사이트의 경우는 응답크기를 줄이는 캐시 방식 외에 HTTP 요청수를 줄이는 캐시 방식을 추가로 사용한다.

#### 1.2.1.1 HTTP 응답 크기를 줄이는 캐쉬 방식
서버에 리소스(img, css등등)를 요청을 하면 서버는 응답시 Last-Modified 헤더 속성에 컨텐츠의 변경일자를 내려보낸다.
이후 브라우저가 서버에 동일 컨텐츠를 요청할때 해당 컨텐츠의 변경일자를 If-Modified-Since속성에 넣어서 보낸다.
웹서버는 그 If-Modified-Since정보와 요청한 컨텐츠의 변경일자와 비교해 동일하면 304 Not Modified응답을 보내주고 컨텐츠를 내려보내주지 않는다.
만약 변경이자가 틀리다면 200OK와 함께 Last-Modified속성과 컨텐츠를 내려 보낸다.

당연하게도 변경일자를 비교해야하기 때문에 서버 요청은 요청시마다 이루어지며 단지 캐시를 사용하는 경우 컨텐츠를 내려받지 않으므로 응답 크기가 줄어든다.
   
#### 1.2.1.2 Etag
HTTP 1.0에서는 URI와 변경일자를 기반으로 캐쉬 유효성을 검증햇지만 HTTP 1.1부터 ETag기반으로 유효성을 체크 할 수 있게 되었다.   

일반적으로 Etag는 Inode를 사용하는데 여러대의 웹서버를 묶어서 사용하면 서버마다 inode값이 다르기 때문에 의도치 않게 200OK를 계속 보내는 케이스가 생긴다.
이럴 경우 Inode를 제거해야 한다.
    
#### 1.2.1.2 HTTP 요청수를 줄이는 캐시 방식
Cache-Control속성을 사용해서 HTTP요청 자체를 하지 않도록 하는 방식인데 Cache-Control의 max-age 설정값을 통해 응답을 받은 이후 일정 시간동안 서버에 요청을 하지 않게 할 수 있다.

max-age는 초단위로 설정되므로 max-age=2592000은 30일 x 86400(1일) = 2592000 즉 30일이다.
 
max-age는 요청 자체를 안하니 성능 개선의 효과는 크지만 컨텐츠가 변경되더라도 일정 시간동안 갱신을 할 수 없다. 그래서 해당 컨텐츠가 변경되면 컨텐츠 자체를 새로운 이름으로 변경해야 한다.

    사용 예 - nginx
    expires max;            2037년으로 설정됨
    expires off;            expires 기능을 비활성화
    expires epoch;
    expires 24h;            h:시간 d:일 y:년
    expires modified +24h;
    expires @24h;
    expires 0;
    expires -1;
    
    ... location {
        expires 30d;        사용법
        ...
    }

eTag가 존재 할 경우 etag를 비교를 우선시 하기에 expires가 없더라도 컨텐츠가 변경될 경우 변경된 컨텐츠를 다운로드 받아서 보여준다.


## 1.3 병렬/비동기 처리

### 1.3.1 네트워크 연결
브라우저는 한 페이지 안에서 한 도메인에 대해 네트워크 연결 갯수가 제한되어 있다. 하지만 동일한 웹서버에 대해 2개의 도메인을 구성하게 되면 네트워크의 연결을 최대 두배까지 열 수 있다.

하지만 동시 연결수 증가는 작업 스레드를 증가시켜 스레드 부족을 유발하니 스레드 수 설정을 증가 시켜야 한다.

### 1.3.2 Ajax와 Dom을 이용한 비동기 처리
업무 포탈 화면 같은 한 화면에 통계 같은 시간이 걸리는 정보를 보여주는 페이지라면 각각의 항목을 비동기 처리해서 먼저 보여줄 수 있는 것부터 빠르게 보여주는 것이 성능 개선에 도움이 된다.

또는 탭으로 구성된 화면일 경우 보여지는 부분만 처리하고 나머지 탭은 사용자가 선택시 그 화면을 처리하도록 구성하면 시간을 개선 할 수 있다.
물론 탭을 선택 했을때 다소 느린 측면이 있을지 몰라도 초기 화면의 응답시간을 개선할 수 있다.


## 1.4 기타 성능 개선

### 1.4.1 CSS와 Javascript는 병렬 처리를 고려해서 배치한다
CSS를 다운로드 하는 순간 Javascript파일을 다운로드 할 수 있지만 반대로 Javascript를 다운받으면서 CSS를 다운받을 수 없다.
그러니 CSS를 JavaScript앞에 배치해서 일부 Javascript파일은 병렬 처리 되도록 한다.

### 1.4.2 CSS는 HEAD 태그에 기술한다
모든 CSS가 다운로드 될때까지 브라우저는 렌더링을 미룬다. CSS가 BODY안에 있으면 랜더링 중간 중간에 전체 또는 부분적인 재 렌더링을 유발 할 수 있으므로 HEAD에 위치시켜 확실하게 먼저 로딩되게 해야한다.
 
### 1.4.3 HTTP 요청은 하나의 패킷으로 처리한다
통상 네트워크 패킷은 1500byte정도이므로 이범위를 최대한 넘지 않게 한다.

### 1.4.4 HTML안에 CSS와 Javascript는 개별 파일로 처리한다
HTML안에 인라인형태로 CSS나 Javascript있으면 각각의 항목을 로딩하기 전까지 렌더링을 지연시킨다. 그래서 보통 CSS나 JS는 외부 파일로 분리 한다.
왜냐하면 HTML파일 크기가 커지기 때문이다.

### 1.4.5 Image는 크기를 명시한다.
이미지를 내려받기 전에 화면 랜더링이 시작될 수 잇는데 이미지를 받은 수 이미지 크기 때문에 다시 화면이 그려지는 경우가 있다. 이를 방지하기 위해 이미지의 파일 가로, 세로크기를 명시적으로 지정한다.

### 1.4.6 HTML의 일부 내용은 먼저 전송 되도록 처리한다.
어플리케이션이 느리면 어쩔 수 없이 화면을 구성하는 컨텐츠도 다운로드가 지연된다. 이런 경우 어플리케이션이 완료되지 않더라도 먼저 HEAD안의 CSS, Javascript를 먼저 다운로드 함으로써 성능 개선을 할 수 있다.

이렇게 하려면 어플리케이션이 실행되는 중간에 응답을 flush해야 한다. HTTP 1.1부터 chunked 방식의 전송이 가능해져서 전체 응답 크기를 몰라도 부분 전송이 가능하다.

### 1.4.7 CSS에 @import를 사용하지 않는다.
@import는 무조건 javascript가 다운로드 되고 다운을 시작하게 되기 때문이다.


## 1.5 웹서버 설정 - nginX

### 1.5.1 최대 병렬 처리 수
어플리케이션의 로직 처리는 업무의 로직처리이기 때문에 단순하지가 않다. 그렇기에 너무 많은 작업 스레드를 만들어서 DB부하가 증가하고 WAS가 버틸수 있는 최대 성능을 넘어가는 동시 처리 요청이 들어오면 TPS는 증가하지 않으면서 응답시간만 증가한다.
그렇기에 최대한 WAS가 최대 성능을 발휘 할 수 있는 정도로 스레드 갯수를 조절한다.

하지만 웹서버는 WAS와 틀리게 CPU같은 자원보다는 네트워크 자원에 대한 의존도가 높다. 왜냐면 웹서버가 처리하는 업무는 어플리케이션 로직보다는 간단하기 때문이다.

웹서버 thread pool 갯수를 설정할때 한사용자당 1개의 thread을 사용할 것이라고 생각하면 안된다. 보통 브라우저는 한도메인당 6개의 네트워크 연결을 웹 서버와 맺어서 컨텐츠를 내려받는다.

항상 6개를 사용하는 건 아니지만 컨텐츠 수가 많으면 2~4개까지 사용하는것을 흔히 볼수 있다. 그리고 네트워크 연결은 스레드를 하나 사용한다고 볼수 있다. 1개의 브라우저는 1개이상의 thread를 사용하고 있다고 볼수 있다.

### 1.5.2 KeepAlive
기존 1.0때는 한페이지에 100개의 컨텐츠가 있다면 100번 네트워크를 연결하고 종료하고 했었다. 그러다보니 네트워크 오버헤드로 인해 성능 저하가 있었다.

이런것을 개선하고자 1.1에서 KeepAlive를 만들었는데 이것은 한번 네트워크를 연결하면 이것을 반복으로 사용해서 여러 컨텐츠를 내려받게 하는 기능이다. 즉 KeepAlive는 한페이지에 많은 컨텐츠가 있을 경우 성능 개선에 효과가 있다.
 
하지만 KeepAlive를 너무 높게 설정한 경우는 웹서비스를 처리하는 갯수가 적더라도 기존 사용자의 네트워크 연결을 계속 연결하고 있기 때문에 새롭게 들어오는 사용자의 요청을 서비스할 수 없는 상태가 되기도 한다.
                                   
쉽게 말해 놀고 있는 Thread가 많다 하더라도 그 노는 스레드들은 KeepAlive로 인해 기존에 요청한 사용자랑 물려 있으니 새로운 요청에 대한 스레드 배정이 안되게 되는 것이다.

그러나 Event-Driven Architecture로 Non-blocking I/O를 사용하는 Nginx는 Keepaliave상태에서도 스레드를 점유하지 않는 구조로 적은 프로세스로도 많은 사용자를 처리 할 수 있다는 장점이 있다.

그리고 Keepalive는 최대한 적게 설정 는하게 좋은데 Unix나 linux같은 환경에서는 네트워크를 하나하나 열때마다 File Descriptor를 하나씩 사용한다.
File Descriptor는 프로세스 단위로 갯수 제약이 있어서 한계에 도달하면 네트워크나 파일을 열 수 없어 에러가 발생한다.

    nginx
    keepalive_timeout  65;
    keepalive_timeout  0; 0일경우 사용안한다는 듯이다.
    
File Descriptor는 [여기](http://dev-ahn.tistory.com/96)를 참고 하기 바란다.   
    




